import 'dotenv/config';
import { Telegraf, Scenes, session } from 'telegraf';
import { UserService } from './services/User.service.js';
import { OrderService } from './services/Order.service.js';
import { PaymentCryptoService } from './services/PaymentCrypto.service.js';
import { PaymentFiatService } from './services/PaymentFiat.service.js';
import { GenerationService } from './services/Generation.service.js';
import { ReferralService } from './services/Referral.service.js';
import { MESSAGES, KEYBOARDS, PACKAGES, SUPPORTED_CRYPTO, REFERRAL_ENABLED } from './config.js';
import { 
    createCatalogKeyboard, 
    createCryptoKeyboard, 
    createChainKeyboard,
    createPaymentCryptoKeyboard,
    createAfterPaymentKeyboard 
} from './screens/keyboards.js';
import { getMemeById } from './utils/memeLoader.js';

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ –±–æ—Ç–∞
if (!process.env.BOT_TOKEN) {
    console.error('‚ùå BOT_TOKEN not found in .env file');
    process.exit(1);
}

const bot = new Telegraf(process.env.BOT_TOKEN);
const userService = new UserService();
const orderService = new OrderService();
const paymentCryptoService = new PaymentCryptoService();
const paymentFiatService = new PaymentFiatService();
const generationService = new GenerationService();
const referralService = new ReferralService();

// Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
bot.use(async (ctx, next) => {
    const start = Date.now();
    await next();
    const ms = Date.now() - start;
    console.log(`‚è±Ô∏è Response time: ${ms}ms`);
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start
bot.start(async (ctx) => {
    try {
        const userId = ctx.from.id;
        const startPayload = ctx.startPayload;

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã—Ö —Å—Å—ã–ª–æ–∫
        if (startPayload) {
            if (startPayload.startsWith('ref_')) {
                const referrerId = parseInt(startPayload.replace('ref_', ''));
                await referralService.processUserReferral(referrerId, userId);
            } else if (startPayload.startsWith('expert_')) {
                const expertId = parseInt(startPayload.replace('expert_', ''));
                await referralService.processExpertReferral(expertId, userId);
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await userService.createUser(ctx.from, startPayload);

        // –û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        await ctx.reply(MESSAGES.WELCOME, KEYBOARDS.MAIN_MENU);
    } catch (err) {
        console.error('‚ùå Error in /start:', err);
        await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
bot.action('main_menu', async (ctx) => {
    try {
        await ctx.editMessageText(MESSAGES.WELCOME, KEYBOARDS.MAIN_MENU);
    } catch (err) {
        await ctx.reply(MESSAGES.WELCOME, KEYBOARDS.MAIN_MENU);
    }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ –º–µ–º–æ–≤
bot.action(/catalog.*/, async (ctx) => {
    try {
        const callbackData = ctx.callbackQuery.data;
        let page = 0;
        
        if (callbackData.includes('catalog_page_')) {
            page = parseInt(callbackData.replace('catalog_page_', ''));
        }
        
        const keyboard = createCatalogKeyboard(page);
        await ctx.editMessageText(MESSAGES.MEMES_CATALOG, keyboard);
    } catch (err) {
        console.error('‚ùå Error in catalog:', err);
        await ctx.answerCbQuery('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞');
    }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –º–µ–º–∞
bot.action(/meme_(.+)/, async (ctx) => {
    try {
        const memeId = ctx.match[1];
        const meme = getMemeById(memeId);
        
        if (!meme) {
            return await ctx.answerCbQuery('–ú–µ–º –Ω–µ –Ω–∞–π–¥–µ–Ω');
        }
        
        if (meme.status === 'soon') {
            return await ctx.answerCbQuery(MESSAGES.MEME_SOON, { show_alert: true });
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–≤–æ—Ç—ã
        const userId = ctx.from.id;
        const hasQuota = await userService.hasQuota(userId);
        
        if (!hasQuota) {
            await ctx.editMessageText(MESSAGES.NO_QUOTA, {
                inline_keyboard: [
                    [{ text: 'üí≥ –ö—É–ø–∏—Ç—å –≤–∏–¥–µ–æ', callback_data: 'buy' }],
                    [{ text: 'üîô –ù–∞–∑–∞–¥', callback_data: 'catalog' }]
                ]
            });
            return;
        }
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π –º–µ–º –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ (–¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–∏—Ö —à–∞–≥–æ–≤)
        ctx.session = ctx.session || {};
        ctx.session.selectedMeme = memeId;
        
        // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –∏–º—è
        await ctx.editMessageText(MESSAGES.ENTER_NAME, {
            inline_keyboard: [
                [{ text: 'üîô –ù–∞–∑–∞–¥', callback_data: 'catalog' }]
            ]
        });
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –æ–∂–∏–¥–∞–Ω–∏—è –≤–≤–æ–¥–∞ –∏–º–µ–Ω–∏
        ctx.session.waitingFor = 'name';
        ctx.session.memeId = memeId;
        
    } catch (err) {
        console.error('‚ùå Error selecting meme:', err);
        await ctx.answerCbQuery('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞');
    }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (–≤–≤–æ–¥ –∏–º–µ–Ω–∏)
bot.on('text', async (ctx) => {
    try {
        ctx.session = ctx.session || {};
        
        if (ctx.session.waitingFor === 'name') {
            const name = ctx.message.text.trim();
            
            // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–º–µ–Ω–∏
            if (name.length < 2 || name.length > 30) {
                return await ctx.reply('‚ùå –ò–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 2 –¥–æ 30 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
            }
            
            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞—Ç (–º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å)
            const badWords = ['–º–∞—Ç1', '–º–∞—Ç2']; // –î–æ–±–∞–≤—å—Ç–µ —Ä–µ–∞–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞
            const hasBadWords = badWords.some(word => name.toLowerCase().includes(word));
            
            if (hasBadWords) {
                return await ctx.reply('‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∏–º—è –±–µ–∑ –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏–π.');
            }
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è –∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ø–æ–ª
            ctx.session.generationName = name;
            ctx.session.waitingFor = 'gender';
            
            await ctx.reply(MESSAGES.CHOOSE_GENDER, KEYBOARDS.GENDER_CHOICE);
            
        } else if (ctx.session.waitingFor === 'email') {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ email –¥–ª—è –æ–ø–ª–∞—Ç—ã –∫–∞—Ä—Ç–æ–π
            const email = ctx.message.text.trim();
            
            // –ü—Ä–æ—Å—Ç–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è email
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                return await ctx.reply('‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
            }
            
            ctx.session.email = email;
            delete ctx.session.waitingFor;
            
            // –°–æ–∑–¥–∞—ë–º –ø–ª–∞—Ç—ë–∂ —á–µ—Ä–µ–∑ Lava
            const payment = await paymentFiatService.createPayment({
                userId: ctx.from.id,
                email: email,
                amount: PACKAGES.single.rub,
                bank: 'BANK131',
                package: 'single'
            });
            
            if (payment.error) {
                return await ctx.reply('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞: ' + payment.error);
            }
            
            await ctx.reply(
                `üí≥ –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π\n\n–°—É–º–º–∞: ${PACKAGES.single.rub}‚ÇΩ\n\n–£ –≤–∞—Å –µ—Å—Ç—å 1 —á–∞—Å –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã!`,
                {
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'üí≥ –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ', url: payment.output.url }],
                            [{ text: 'üîô –ù–∞–∑–∞–¥', callback_data: 'buy' }]
                        ]
                    }
                }
            );
        }
    } catch (err) {
        console.error('‚ùå Error in text handler:', err);
        await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –ø–æ–ª–∞
bot.action(/gender_(male|female)/, async (ctx) => {
    try {
        ctx.session = ctx.session || {};
        const gender = ctx.match[1];
        ctx.session.generationGender = gender;
        
        const name = ctx.session.generationName;
        const genderText = gender === 'male' ? '–ú–∞–ª—å—á–∏–∫' : '–î–µ–≤–æ—á–∫–∞';
        
        await ctx.editMessageText(
            MESSAGES.CONFIRM_GENERATION(name, gender),
            KEYBOARDS.CONFIRM_GENERATION
        );
    } catch (err) {
        console.error('‚ùå Error in gender selection:', err);
        await ctx.answerCbQuery('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞');
    }
});

// –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
bot.action('confirm_gen', async (ctx) => {
    try {
        const userId = ctx.from.id;
        const memeId = ctx.session.memeId;
        const name = ctx.session.generationName;
        const gender = ctx.session.generationGender;
        
        // –°–ø–∏—Å—ã–≤–∞–µ–º –∫–≤–æ—Ç—É
        const deducted = await userService.deductQuota(userId);
        if (!deducted) {
            return await ctx.answerCbQuery('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π', { show_alert: true });
        }
        
        // –°–æ–∑–¥–∞—ë–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
        const generation = await generationService.createGeneration({
            userId,
            memeId,
            name,
            gender
        });
        
        if (generation.error) {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–≤–æ—Ç—É –ø—Ä–∏ –æ—à–∏–±–∫–µ
            await userService.refundQuota(userId);
            return await ctx.answerCbQuery('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏', { show_alert: true });
        }
        
        await ctx.editMessageText(MESSAGES.GENERATION_STARTED);
        
        // –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        await waitForGeneration(ctx, generation.generationId);
        
        // –û—á–∏—â–∞–µ–º —Å–µ—Å—Å–∏—é
        delete ctx.session.memeId;
        delete ctx.session.generationName;
        delete ctx.session.generationGender;
        delete ctx.session.waitingFor;
        
    } catch (err) {
        console.error('‚ùå Error confirming generation:', err);
        await ctx.answerCbQuery('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞');
    }
});

// –§—É–Ω–∫—Ü–∏—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
async function waitForGeneration(ctx, generationId, maxAttempts = 60) {
    for (let i = 0; i < maxAttempts; i++) {
        await new Promise(resolve => setTimeout(resolve, 3000)); // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã
        
        const generation = await generationService.getGeneration(generationId);
        
        if (generation.status === 'done' && generation.videoUrl) {
            try {
                await ctx.replyWithVideo(
                    { url: generation.videoUrl },
                    { caption: MESSAGES.GENERATION_SUCCESS }
                );
            } catch (err) {
                await ctx.reply(
                    MESSAGES.GENERATION_SUCCESS + '\n\n–°—Å—ã–ª–∫–∞ –Ω–∞ –≤–∏–¥–µ–æ: ' + generation.videoUrl
                );
            }
            return;
        } else if (generation.status === 'failed') {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–≤–æ—Ç—É
            await userService.refundQuota(ctx.from.id);
            await ctx.reply(MESSAGES.GENERATION_FAILED);
            return;
        }
    }
    
    // Timeout
    await ctx.reply('‚è∞ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–Ω–∏–º–∞–µ—Ç –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏. –ú—ã –æ—Ç–ø—Ä–∞–≤–∏–º –≤–∞–º –≤–∏–¥–µ–æ, –∫–æ–≥–¥–∞ –æ–Ω–æ –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ.');
}

// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
bot.launch()
    .then(() => {
        console.log('‚úÖ MeeMee bot started successfully!');
        console.log(`Bot username: @${bot.botInfo.username}`);
    })
    .catch(err => {
        console.error('‚ùå Failed to start bot:', err);
        process.exit(1);
    });

// Graceful shutdown
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
