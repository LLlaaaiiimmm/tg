import 'dotenv/config';
import axios from 'axios';
import redis from '../redis.js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class GenerationService {
    constructor() {
        this.apiKey = process.env.GOOGLE_VEO3_API_KEY;
        // Google Veo 3.1 API endpoint (—á–µ—Ä–µ–∑ Gemini API)
        this.apiUrl = `https://generativelanguage.googleapis.com/v1beta`;
        this.modelName = 'veo-3.1-generate-preview';
    }

    // –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–º–ø—Ç–∞ –º–µ–º–∞
    loadMemePrompt(memeId) {
        try {
            const memePath = path.join(__dirname, '../memes', `${memeId}.json`);
            const memeData = JSON.parse(fs.readFileSync(memePath, 'utf8'));
            return memeData;
        } catch (err) {
            console.error(`‚ùå Error loading meme ${memeId}: ${err.message}`);
            return null;
        }
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    async createGeneration({ userId, memeId, name, gender }) {
        try {
            const generationId = this.generateId();
            const memeData = this.loadMemePrompt(memeId);

            if (!memeData) {
                return { error: '–ú–µ–º –Ω–µ –Ω–∞–π–¥–µ–Ω' };
            }

            const genderText = gender === 'male' ? '–º–∞–ª—å—á–∏–∫' : '–¥–µ–≤–æ—á–∫–∞';
            const prompt = memeData.prompt
                .replace('{name}', name)
                .replace('{gender}', gender)
                .replace('{gender_text}', genderText);

            const generation = {
                generationId,
                userId,
                memeId,
                memeName: memeData.name,
                name,
                gender,
                prompt,
                status: 'queued',
                videoUrl: null,
                error: null,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            await redis.set(`generation:${generationId}`, JSON.stringify(generation));
            await redis.lpush('generation_queue', generationId);
            await redis.lpush(`user_generations:${userId}`, generationId);

            console.log(`üé¨ Generation ${generationId} created for user ${userId}`);

            // –ó–∞–ø—É—Å–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
            this.processGeneration(generationId).catch(err => {
                console.error(`‚ùå Error processing generation ${generationId}: ${err.message}`);
            });

            return generation;
        } catch (err) {
            console.error(`‚ùå Error creating generation: ${err.message}`);
            return { error: err.message };
        }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    async processGeneration(generationId) {
        try {
            const generation = await this.getGeneration(generationId);
            if (!generation) return;

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            await this.updateGeneration(generationId, { status: 'processing' });

            // –í—ã–∑–æ–≤ Google Veo3 API
            const videoUrl = await this.generateVideo(generation.prompt);

            if (videoUrl) {
                await this.updateGeneration(generationId, {
                    status: 'done',
                    videoUrl: videoUrl
                });
                console.log(`‚úÖ Generation ${generationId} completed successfully`);
            } else {
                throw new Error('Failed to generate video');
            }
        } catch (err) {
            console.error(`‚ùå Generation ${generationId} failed: ${err.message}`);
            await this.updateGeneration(generationId, {
                status: 'failed',
                error: err.message
            });
        }
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ Google Veo3 API
    async generateVideo(prompt) {
        try {
            if (!this.apiKey) {
                throw new Error('Google Veo3 API key not configured');
            }

            console.log('üé¨ Starting video generation with Veo3...');
            console.log('Prompt:', prompt);

            // –†–µ–∞–ª—å–Ω—ã–π API –∑–∞–ø—Ä–æ—Å –∫ Google Veo 3.1
            const response = await axios.post(
                `${this.apiUrl}/models/${this.modelName}:generateContent?key=${this.apiKey}`,
                {
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }],
                    generationConfig: {
                        responseCount: 1,
                        aspectRatio: '16:9',
                        duration: 5
                    }
                },
                {
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    timeout: 300000 // 5 –º–∏–Ω—É—Ç
                }
            );

            console.log('API Response:', JSON.stringify(response.data, null, 2));

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞
            if (response.data && response.data.candidates && response.data.candidates.length > 0) {
                const candidate = response.data.candidates[0];
                
                // –ï—Å–ª–∏ –≤–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ —Å—Ä–∞–∑—É
                if (candidate.content && candidate.content.parts && candidate.content.parts[0].video) {
                    const videoUri = candidate.content.parts[0].video.uri;
                    console.log('‚úÖ Video URL received:', videoUri);
                    return videoUri;
                }
                
                // –ï—Å–ª–∏ –µ—Å—Ç—å operation ID –¥–ª—è polling
                if (response.data.name || response.data.operation) {
                    const operationName = response.data.name || response.data.operation;
                    console.log('‚è≥ Operation started:', operationName);
                    return await this.pollVideoGeneration(operationName);
                }
            }

            throw new Error('Invalid API response: no video or operation ID');
        } catch (err) {
            console.error(`‚ùå Video generation error: ${err.message}`);
            if (err.response) {
                console.error('API Error Response:', err.response.data);
            }
            throw err;
        }
    }

    // Polling –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    async pollVideoGeneration(operationName, maxAttempts = 60, interval = 5000) {
        console.log('‚è≥ Starting polling for operation:', operationName);
        
        for (let i = 0; i < maxAttempts; i++) {
            try {
                const response = await axios.get(
                    `${this.apiUrl}/${operationName}?key=${this.apiKey}`,
                    {
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }
                );

                console.log(`Polling attempt ${i + 1}/${maxAttempts}...`);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–∏
                if (response.data.done === true) {
                    if (response.data.error) {
                        throw new Error(response.data.error.message || 'Generation failed');
                    }
                    
                    // –í–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ
                    if (response.data.response && response.data.response.candidates) {
                        const candidate = response.data.response.candidates[0];
                        if (candidate.content && candidate.content.parts && candidate.content.parts[0].video) {
                            const videoUri = candidate.content.parts[0].video.uri;
                            console.log('‚úÖ Video generation completed:', videoUri);
                            return videoUri;
                        }
                    }
                    
                    throw new Error('Operation completed but no video found');
                }

                // –ñ–¥—ë–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
                await new Promise(resolve => setTimeout(resolve, interval));
            } catch (err) {
                console.error(`‚ùå Polling error: ${err.message}`);
                
                // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞, –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É
                if (i === maxAttempts - 1) {
                    throw err;
                }
                
                // –ò–Ω–∞—á–µ –∂–¥—ë–º –∏ –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞
                await new Promise(resolve => setTimeout(resolve, interval));
            }
        }

        throw new Error('Video generation timeout after ' + (maxAttempts * interval / 1000) + ' seconds');
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    async getGeneration(generationId) {
        const data = await redis.get(`generation:${generationId}`);
        return data ? JSON.parse(data) : null;
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    async updateGeneration(generationId, data) {
        const generation = await this.getGeneration(generationId);
        if (!generation) return null;

        const updated = {
            ...generation,
            ...data,
            updatedAt: new Date().toISOString()
        };

        await redis.set(`generation:${generationId}`, JSON.stringify(updated));
        return updated;
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    async getUserGenerations(userId) {
        const generationIds = await redis.lrange(`user_generations:${userId}`, 0, -1);
        const generations = [];

        for (const id of generationIds) {
            const gen = await this.getGeneration(id);
            if (gen) generations.push(gen);
        }

        return generations;
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è ID
    generateId() {
        const timestamp = Date.now();
        const random = Math.floor(Math.random() * 10000);
        return `GEN-${timestamp}-${random}`;
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π
    async getGenerationStats() {
        const queueLength = await redis.llen('generation_queue');
        
        // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ ID –≥–µ–Ω–µ—Ä–∞—Ü–∏–π (–º–æ–∂–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å)
        const allKeys = await redis.keys('generation:*');
        const stats = {
            total: allKeys.length,
            queued: 0,
            processing: 0,
            done: 0,
            failed: 0
        };

        for (const key of allKeys) {
            const gen = await redis.get(key);
            if (gen) {
                const { status } = JSON.parse(gen);
                stats[status] = (stats[status] || 0) + 1;
            }
        }

        return { ...stats, queueLength };
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–ø –º–µ–º–æ–≤
    async getTopMemes() {
        const allKeys = await redis.keys('generation:*');
        const memeCounts = {};

        for (const key of allKeys) {
            const gen = await redis.get(key);
            if (gen) {
                const { memeId, memeName, status } = JSON.parse(gen);
                if (status === 'done') {
                    if (!memeCounts[memeId]) {
                        memeCounts[memeId] = { memeId, memeName, count: 0 };
                    }
                    memeCounts[memeId].count++;
                }
            }
        }

        return Object.values(memeCounts)
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);
    }
}